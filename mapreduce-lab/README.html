<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Cloud computing laboratory</title>
</head>
<body>
<h1>MapReduce Lab</h1>
<p>
In this laboratory the user will learn how to use the
<a href="http://hadoop.apache.org">Hadoop</a> client API by implementing
a set of well know MapReduce techniques:
<a href="#wordcount">Word Count</a>,
<a href="#pair">Pair</a>,
<a href="#stripes">Stripes</a>,
<a href="#orderinversion">Order Inversion</a>,
<a href="#joins">Join</a>


<h2 id="wordcount">Word Count</h2>
Count the occurrences of each word inside a text file.
This is the simplest example of MapReduce job and has to be implemented in three
different ways:
    <ol>
    <li><b>Basic</b>: the map method emit 1 for each word. The reduce aggregate
                      the ones and save on disk the result.</li>
    <li><b>In-Memory Combiner</b>: instead of emitting 1 for each word, the
                                   map method aggregate the ones and emit the result
                                   for each word.</li>
    <li><b>Combiner</b>: the same as In-Memory Combiner but using the MapReduce
                         Combiner class.</li>
    </ol>

<h3>Instructions</h3>
For the <b>basic</b> version the user has to modify the file <i>WordCount.java</i> in
the package <i>fr.eurecom.dsg.mapreduce</i>. The user must change each TODO
with its own code following the TODO informations.<br />

For The <b>In-Memory</b> Combiner and the <b>Combiner</b> the user has to modify
<i>WordCountIMC.java</i>
and <i>WordCountCombiner.java</i> in the same package. The user must change each
TODO using the same code of the basic word count example except for the TODOs
marked with a star *. Those must be changed with the correct design pattern.

<h3>Example of usage</h3>
The final version should get in input three arguments: the number of reducers,
the input file and the output path. Example of execution are:<br />

<code>
hadoop jar &lt;compiled_jar&gt; fr.eurecom.dsg.mapreduce.WordCount 3 &lt;input_file&gt; &lt;output_path&gt;<br />
hadoop jar &lt;compiled_jar&gt; fr.eurecom.dsg.mapreduce.WordCountIMC 3 &lt;input_file&gt; &lt;output_path&gt;<br />
hadoop jar &lt;compiled_jar&gt; fr.eurecom.dsg.mapreduce.WordCountCombinator 3 &lt;input_file&gt; &lt;output_path&gt;<br />
</code>

<br />
To test your code use the file <a href="inputs/quote">quote</a>.
Expected result in the file <a href="inputs/wc_quote.out">wordcount quote result</a>.


<h2 id="pair">Pair</h2>
Use a composite key to emit an occurrence of a pair of words. In
this exercise the user will understand how to create a Hadoop data type that can
be used for MapReduce jobs.<br />
A Pair is a tuple composed by two elements that is
usually used to ship two object inside one object. For this exercise the user has
to implement a TextPair, that is a Pair that contains two words.

<h3>Instructions</h3>
There are two files for this exercise:
<ul>
    <li><i>TextPair.java</i>: data structure to be implemented by the user. Besides the
                              implementation of the data structure itself, the user
                              has to implement the serialization Hadoop API (write and readFields).</li>
    <li><i>Pair.java</i>: the implementation of a pair example using <i>TextPair.java</i>
                          as datatype. <b>The user must not change this file</b>.</li>
</ul>

<h3>Example of usage</h3>
The final version should get in input three arguments: the number of reducers,
the input file and the output path. Example of execution are:<br />
<code>
hadoop jar &lt;compiled_jar&gt; fr.eurecom.dsg.mapreduce.Pair 1 &lt;input_file&gt; &lt;output_path&gt;<br />
</code>

<br />
To test your code use the file <a href="inputs/quote">quote</a>.
Expected result in the file <a href="inputs/pair_quote.out">pair quote result</a>.


<h2 id="stripes">Stripes</h2>
Stripes are used to put inside a value an associative array that can be serialized
and deserialized. The exercise is the same as Pair, but using your structure.

<h3>Instructions</h3>
There are two files for this exercise:
<ul>
    <li><i>StringToIntAssociativeArray.java</i>: the data structure file, to be
                                                 implemented</li>
    <li><i>Stripes.java</i>: the MapReduce job, that the user must implement
                             using the StringToIntAssociativeArray data structure</li>
</ul>

<h3>Example of usage</h3>
<code>
hadoop jar &lt;compiled_jar&gt; fr.eurecom.dsg.mapreduce.Stripes 2 &lt;input_file&gt; &lt;output_path&gt;<br />
</code>

<br />
To test your code use the file <a href="inputs/quote">quote</a>.
Expected result in the file <a href="inputs/stripe_quote.out">stripes quote result</a>.


<h2 id="orderinversion">Order Inversion</h2>
Order inversion is a design pattern used for computing relative frequencies.
What is the number of occourrence of a pair containing a word as first element
related to the number of occourrence of that word. For instance, if the word
"dog" followed by the word "cat" occours 10 times and the word "dog" occours
20 in total, we say that the frequency of the pair ("dog","cat") is 0.5.
The user has to implement the map and reduce method and the special partitioner
(see OrderInversion.PartitionerTextPair class) that permits to send all data
about a particular word to a single reducer.
Note that inside the OrderInversion class there is a field called ASTERISK which
should be used for output the total number of occourrence of a word. Refer to
slides for more informationss

<h3>Instructions</h3>
There is one file for this exercise called <i>OrderInversion.java</i>. The run
method of the job is already implemented, the user should program the mapper, the
reducer and the partitioner (see the TODO)

<h3>Example of usage</h3>
<code>
hadoop jar &lt;compiled_jar&gt; fr.eurecom.fr.mapreduce.OrderInversion 4 &lt;input_file&gt; &lt;output_path&gt;<br />
</code>

<br />
To test your code use the file <a href="inputs/quote">quote</a>.
Expected result in the file <a href="inputs/oi_quote.out">order inversion quote result</a>.

<h2 id="joins">Joins</h2>
In MapReduce the term join refers to merging two different dataset stored as
unstructured files on HDFS. As for databases, in MapReduce there are many different
kind of joins, each one with its use-cases and constraints. In this laboratory
the user will implement two different kind of MapReduce joins techniques:
<ul>
    <li><b>Distributed Cache Join</b>: this join technique is
        use when on of the two files that you want to join is small enough to
        stay on each computer of the cluster. This file is copied locally to each
        computer using the Hadoop cache system and then loaded by the map phase.
    </li>
    <li><b>Reduce-Side Join</b>: in this case the map phase tags each record
                                 such that records of different inputs that
                                 have to be joined will have the same tag. Each
                                 reducer will receive a tag with a list of records
                                 and perform the join.</li>
</ul>

<h3>Instructions</h3>
<ul>
    <li><b>Distributed Cache Join</b>: the file is <i>DistributedCacheJoin.java</i>, for
        the distributed cache use the
        <a href="https://hadoop.apache.org/common/docs/r0.20.2/api/org/apache/hadoop/filecache/DistributedCache.html">DistributedCache API</a>.
    </li>
    <li><b>Reduce Side Join</b>: the file is <i>ReduceSideJoin.java</i>. This
        exercise is different from the others because it does not contain any
        information on how to do it. The user is free to choose how to implement it.
    </li>
</ul>

<h3>Example of usage</h3>
<code>
hadoop jar &lt;compiled_jar&gt; fr.eurecom.fr.mapreduce.DistributedCacheJoin 1 &lt;big_file&gt; &lt;small_file&gt; &lt;output_path&gt;<br />
hadoop jar &lt;compiled_jar&gt; fr.eurecom.fr.mapreduce.ReduceSideJoin 1 &lt;input_file2&gt; &lt;input_file1&gt; &lt;output_path&gt;<br />
</code>

</body>
</html>